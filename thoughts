performance
	language
		calling into python will suck - use C
		how fast would hasqel be? how easy?
	simics uses JIT for speed - how many orders of magnitude slowdown?

things to do
	figure out symbol table manipulation


stack
	((empty))

algs
	execution poince of interest:
		concurrency ifaces
			mutex_lock, mutex_unlock
			cond_wait, cond_signal, cond_broadcast (or analogous)
			other primitives (sem, rw, rend?)
		single instructions
			cli, sti
			xchg, xadd, cmpxchg, cmpxchg8b(???)
			invlpg (maybe?)
			inb/outb (maybe?)
		core scheduler
			yield (scheduler internal version)
			context switcher
		other
			malloc
				(just set eax to 0 and jump to the return)
	
	or the same for p1 only:
		keyboard 

	NOTE: list the particular bugs we're looking for, and possibly only use
	NOTE: the poince of interest relevant to them at one time.

	what biggest [subtle] bugs are we looking for?
		vanish/wait-related unsafety or deadlocks
		oom robustness
		...

impl details
	things landslide needs to know about the kernel:
		names and/or locations of functions of interest
		is there a scheduler lock we should watch out for
		can we examine (and possibly manipulate) the runqueue?

	how to run the wrapper
		landslide can talk to its past/future selves with a file

questions from the papers
	how will we implement in simics the analogue of reg/unreg, interact?
		agent ~ kthread
		"blocking" impl will need internal tricksiness
	steady state hmm
	need to understand the partial order reduction; will it need porting (no?)
	'stateless exploration' we might be able to do better
	trap on exit from context switcher
	how to bootstrap state for first process
	when a thread is removed from the runqueue - distinguish scenarios?
	make simics stop throwing timer interrupts of its own
	how to avoid devolving always into the timer handler overflow problem
	how to tell when a all blocks (spinning vs otherwise?)
	what is up with the erroneous thing (double unlock)?

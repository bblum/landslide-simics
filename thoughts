performance
	language
		how fast would hasqel be? how easy?
	simics uses JIT for speed - how many orders of magnitude slowdown?

things to do
	figure out symbol table manipulation

algs
	execution poince of interest:
		concurrency ifaces
			mutex_lock, mutex_unlock
			cond_wait, cond_signal, cond_broadcast (or analogous)
			other primitives (sem, rw, rend?)
		single instructions
			cli, sti
			xchg, xadd, cmpxchg, cmpxchg8b(???)
			invlpg (maybe?)
			inb/outb (maybe?)
		core scheduler
			yield (scheduler internal version)
			context switcher
		other
			malloc
				(just set eax to 0 and jump to the return)
	
	or the same for p1 only:
		keyboard 

	NOTE: list the particular bugs we're looking for, and possibly only use
	NOTE: the poince of interest relevant to them at one time.

	what biggest [subtle] bugs are we looking for?
		vanish/wait-related unsafety or deadlocks
		oom robustness
		...
	
	how to deal with sleeping threads?

impl details
	things landslide needs to know about the kernel:
		[x] names and/or locations of functions of interest
		[ ] is there a scheduler lock we should watch out for
		[x] can we examine (and possibly manipulate) the runqueue?

	how to run the wrapper
		landslide can talk to its past/future selves with a file
		test failed detection
			- easy mode: trap on a panic() and be like "welp"
			- deadlock: START__TYPE_COMPLETE & ... 
				spinning mutexes?
					- all threads on RQ in mutex_lock() -> yield()
						have a counter and watch for it being 0
				descheduling mutexes?
					- empty RQ & ... 
				- empty SQ & no readline
					how to tell no readline? (special case)
			- other, e.g. data structure corruption
				much harder :\


questions from the papers
	steady state hmm
	need to understand the partial order reduction; will it need porting (no?)
	'stateless exploration' we might be able to do better
	make simics stop throwing timer interrupts of its own
	how to tell when a call blocks (spinning vs otherwise?)
	what is up with the erroneous thing (double unlock)?

write a guide to using landslide ... 
	We assume...
		that your context switcher works
		that if a thread is on the RQ, a finite number of timer interrupts in succession will cause it to run
	The more asserts you have in your kernel, the easier it will be for landslide to detect if something has gone wrong.


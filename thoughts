performance
	language
		how fast would hasqel be? how easy?
	simics uses JIT for speed - how many orders of magnitude slowdown?

algs
	execution poince of interest:
		concurrency ifaces
			mutex_lock, mutex_unlock
			cond_wait, cond_signal, cond_broadcast (or analogous)
			other primitives (sem, rw, rend?)
		single instructions
			cli, sti
			xchg, xadd, cmpxchg, cmpxchg8b(???)
			invlpg (maybe?)
			inb/outb (maybe?)
		core scheduler
			yield (scheduler internal version)
			context switcher
		other
			malloc
				(just set eax to 0 and jump to the return)
	
	or the same for p1 only:
		keyboard 

	NOTE: list the particular bugs we're looking for, and possibly only use
	NOTE: the poince of interest relevant to them at one time.

	what biggest [subtle] bugs are we looking for?
		vanish/wait-related unsafety or deadlocks
		oom robustness
		...
		memory validation races
		a mutex_lock/yield/switch/etc while interrupts off / scheduler locked
	
	how to deal with sleeping threads?

impl details
	how to run the wrapper
		landslide can talk to its past/future selves with a file
		test failed detection
			- easy mode: trap on a panic() and be like "welp"
			- deadlock: START__TYPE_COMPLETE & ... 
				spinning mutexes?
					- all threads on RQ in mutex_lock() -> yield()
						have a counter and watch for it being 0
				descheduling mutexes?
					- empty RQ & ... 
				- empty SQ & no readline
					how to tell no readline? (special case)
			- other, e.g. data structure corruption
				much harder :\
			- in #PF handler, did the fault occur in kernel mode?
				(not always correct to assume that's never OK)
	test case design
		write specific tests for expected bugs?
			how many? - common problem syscall pairs / triplets / ...

miscellaneous todo
	figure out symbol table manipulation
	make simics stop throwing timer interrupts of its own (and control kbd)
	how to tell when a call blocks (spinning vs otherwise?)
		add a "is this spinning mutex blocked? skip over it" logic
	make arbiter know when it is making the null choice


questions from the papers
	steady state hmm
	need to understand the partial order reduction; will it need porting (no?)
	'stateless exploration' we might be able to do better
	what is up with the erroneous thing (double unlock)?

write a guide to using landslide ... 
	We assume...
		that your context switcher works
		that if a thread is on the RQ, a finite number of timer interrupts in succession will cause it to run
		sleep must not spin-wait.
		readline must not spin-wait.
		memory below USER_MEM_START is direct-mapped.
	The more asserts you have in your kernel, the easier it will be for landslide to detect if something has gone wrong.


on save state and restore state
	save state: fix internal state tracking
	hook in smashing the opponent
